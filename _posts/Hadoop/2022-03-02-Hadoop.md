---
title: "Hadoop 이란?"
header:
  image: /assets/images/hadoop/hadoop_logo.svg
  caption: "Photo credit: [**Wikipedia**](https://upload.wikimedia.org/wikipedia/commons/3/38/Hadoop_logo_new.svg)"
layout: posts
categories:
  - Hadoop
tags:
  - Hadoop
toc: true
# toc_sticky: true
# toc_label: "Hadoop 정리"
---

<br><br>
<a id="home1"></a>

# Hadoop 이란?

<br>

안정적이고 확장성이 높은 저장 및 분석 플랫폼
실제로 '하둡' 이라는 단어는 HDFS와 맵리듀스만이 아닌 수 많은 에코 시스템 프로젝트를 지칭하는 말로 사용되기도 한다.

> 하둡 에코시스템은 분삭 컴퓨팅과 대규모 데이터 처리를 위한 기반 시설
> 하둡 에코시스템의 대부분은 아파치 소프트웨어 재단에서 관리

<br><br>

## 목차

- [MapReduce(전체 데이터 질의)](#1)
- [하둡 처리 패턴](#2)
- [관계형 데이터베이스와의 비교](#3)
- [그리드 컴퓨팅과의 비교](#4)
- [자발적 컴퓨팅과의 비교](#5)
- [하둡 역사](#6)

<br><br>
<a id="1"></a>

# 전체 데이터 질의

<br>

맵리듀스의 접근법은 Brute-force 방식이며 일괄 질의 처리기 <br>
전체 데이터셋을 대상으로 비정형쿼리를 수행하고 합리적인 시간 내에 그 결과를 보여주는 능력을 가지고 있다.

> 비정형 쿼리 : ad hoc 쿼리

<br>

맵리듀스는 일괄 처리 시스템으로 <b><i><u>대화형 분석에는 적합하지 않다.</u></i></b><br>
질의 실행 후 수 초 이내에 결과 받는 것은 불가능.

<br>

[목차로](#home1)

<br><br>
<a id="2"></a>

# 하둡 처리 패턴

<br>

1. <b>대화형 SQL</b> : 대화형 SQL은 맵리듀스 대신 장기 실행 전용 데몬(임팔라 Impala)이나 컨테이너를 재상요하는(테즈 Tez 기반의 하이브) 분산 쿼리 엔진을 사용한다. 대용량 데이터셋에 대한 확장성이 있으면서 하둡 기반의 SQL 쿼리를 실행할 때 빠른 응답 속도

2. <b>반복 처리</b> : 머신러닝과 같은 다수의 알고리즘은 근본적으로 반복 연산을 한다. 따라서 각 반복 단계마다 디스크에서 데이터를 불러오는 것보다는 메모리에 임시 작업 데이터셋을 보존하는 것이 더 효율적이다. 맵리듀스 아키텍처는 이러한 방법을 허용하지 않지만 예를 들어 스파크를 이용하면 매우 간단하게 해결된다. 스파크는 데이터셋을 탐색하는 방식의 작업을 허용한다.

3. <b>스트림 처리</b> : 스톰, 스파크 스티리밍, 삼자와 같은 스트리밍 시스템은 실시간으로 실행되고 경계가 없는 스트림 데이터를 분산 계산하여 그 결과를 하둡 저장소나 외부 시스템에 보낼 수 있다.

4. <b>검색</b> : 솔라 검색 플랫폼은 하둡 클러스터에서 실행될 수 있다. 솔라는 문사를 색인하여 HDFS에 저장하고, HDFS에 저장된 색인을 기반으로 검색 쿼리를 제공한다.

<br>

[목차로](#home1)

<br><br>
<a id="3"></a>

# 관계형 데이터베이스와의 비교

<br>

> 디스크 드라이브의 특성 `탐색 시간은 전송 속도보다 발전이 더디다.`

만약 데이터 접근 패턴이 탐색 위주라면 데이터셋의 커다란 부분을 읽어나 쓰는 작업은 전송 속도에 좌우되는 스트리밍 조작보다 더 오래 걸릴 것이다. 반면 데이터베이스에 있는 일부 레코드를 변경하는 작업은 전통적인 B-트리 가 더 적합하다. 데이터베이스의 상당 부분을 변경할 때 B-트리는 데이터베이스를 재구성하기 위해 Sort/Merge를 사용해야 하므로 맵리듀스보다 효율적이지 못하다.

> 맵리듀스는 비정형 분석과 같이 `일괄 처리 방식으로 전체 데이터셋을 분석할 필요가 있는 문제`에 적합하다.

> RDBMS는 상대적으로 `작은 양의 데이터를 낮은 지연 시간에 추출하고 변경`하기 위해 데이터셋을 색인하기 때문에 `특정 쿼리와 데이터 변경`에 적합하다.

<br>
<div align="center">

#### RDBMS와 맵리듀스의 비교

<br>
<table>
    <thead>
        <tr>
        <th colspan="1"></th>
            <th colspan="1">전통적 RDBMS</th>
            <th colspan="1">맵리듀스</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>데이터 크기</td>
            <td>기가바이트</td>
            <td>페타바이트</td>
        </tr>
        <tr>
            <td>접근방식</td>
            <td>대화형과 일괄 처리 방식</td>
            <td>일괄 처리 방식</td>
        </tr>
        <tr>
            <td>변경</td>
            <td>여러 번 읽고 쓰기</td>
            <td>한 번 쓰고 여러 번 읽기</td>
        </tr>
        <tr>
            <td>트랜잭션</td>
            <td>ACID</td>
            <td>없음</td>
        </tr>
        <tr>
            <td>구조</td>
            <td>쓰기 기준 스키마</td>
            <td>일기 기준 스키마</td>
        </tr>
        <tr>
            <td>무결성</td>
            <td>높음</td>
            <td>낮음</td>
        </tr>
        <tr>
            <td>확장성</td>
            <td>비선형</td>
            <td>선형</td>
        </tr>
    </tbody>
</table>
</div>

<br>

- 정형 데이터 : XML 문서나 미리 정의된 특정 스키마를 가진 데이터베이스 테이블과 같이 형식이 정의된 항목으로 구조화 되어 있으며, RDBMS 영역이다.

- 반정형 데이터 : 정형 데이터에 비해 스키마가 유연하거나 심지어 생략될 수 있다. 데이터 구조에 대한 최소한의 규칙만 있으면 된다.(ex. 스프레드시트[셀 자체에 어떤 형태의 데이터도 담을 수 있다.])

- 비정형 데이터 : 어떠한 내부 구조도 없다.(ex. 텍스트, 이미지)

> 읽기 시점 스키마(schema-on-read)라 불리는 특성은 데이터를 불러오는 비용이 많이 드는 단계도 피할 수 있다. `하둡은 단순히 파일만 복사하면 된다.`

- 관계형 데이터는 무결성을 유지하고 중복을 제거하기 위해 주기적으로 정규화 된다. 정규화는 하둡에서 문제가 되는데, 하둡은 비지역 연산으로 레코드를 읽고, `하둡의 핵심 전제는 고속의 순차적 읽기와 쓰기를 수행`하는 것이기 때문이다.

<br>

[목차로](#home1)

<br><br>
<a id="4"></a>

# 그리드 컴퓨팅과의 비교

<br>

대체로 HPC는 SAN으로 연결된 공유 파일시스템에 접근하는 클러스터 머신 여러 대에 작업을 분산시킨다. 이런 방식은 계산 중심의 작업에서는 좋은 결과를 얻지만 계산 노드들이 대용량(수백 기가바이트 정도) 데이터에 접근해야 할 때는 네트워크 대역폭 때문에 병목 현상이 생기고 계산 노드가 빈둥거리게 되는 문제가 발생한다.

> 고성능 컴퓨팅(HPC. high-performance computing)
> <br>

> SAN(Storage Area Network)은 여러 서버 또는 컴퓨터에서 액세스할 수 있는 스토리지 디바이스 네트워크로, 스토리지 공간의 공유 풀을 제공합니다. 네트워크의 각 컴퓨터는 컴퓨터에 직접 연결된 로컬 디스크처럼 SAN 스토리지에 액세스할 수 있습니다.

<br><br>

하둡은 계산 노드에 데이터를 함께 배치한다. 따라서 데이터가 로컬에 있기 때문에 접근도 빠를 수 밖에 없다. (CDP는 Computing Node와 저장 노드 분리) <br>
하둡은 네트워크 토폴로지를 명확하게 모델링하는 방법으로 네트워크 대역폭을 보존하기 위해 많은 노력을 기울였으며, 네트워크를 고려한 이러한 배치 방식은 하둡에서 cpu를 많이 사용하는 분석에 지장을 주지 않는다.

> 위의 성격을 데이터 지역성(data locality) 이라고 부르며 좋은 성능을 내는 이유라고 한다.

<br><br>

대규모 분산 컴퓨팅에서 수 많은 프로세스를 조율하는 것은 엄청난 과제다. 맵리듀스와 같은 분산 처리 프레임워크는 실패한 테스크를 자동으로 감지하여 장애가 없는 머신에 다시 배치하도록 구현 되어 있다. 의존성이 없는 비공유(shared-nothing) 아키텍처이기 때문이다. MPI 프로그램은 자신의 체크포인트와 장애 복구를 명확하게 관리해야 한다. 개발자에게 더 많은 제어권을 MPI에게 주지만 프로그램 작성은 그만큼 힘들어진다.

> MPI : 메시지 전달 인터페이스(Message Passing Interface, MPI)는 분산 및 병렬 처리에서 정보의 교환에 대해 기술하는 표준이다. 병렬 처리에서 정보를 교환할 때 필요한 기본적인 기능들과 문법, 그리고 프로그래밍 API에 대해 기술하고 있지만 구체적인 프로토콜이나 각각의 구현에 대한 것에 대해서는 기술하지 않는, 하나의 거시적인 테두리를 정해주는 표준으로 이해할 수 있다.

<br>

[목차로](#home1)

<br><br>
<a id="5"></a>

# 자발적 컴퓨팅과의 비교

<br>

> `SETI@home` : 외계 지적 생명체 탐사 프로젝트인 SETI(Search for Extra-Terrestrial Intelligence)는 전파망원경의 데이터를 분석하여 외계의 지적 생명체에 대한 신호를 얻기 위해 자원 봉사자들의 컴퓨터가 쉬고 있을 때 CPU의 연산력을 사용하는 프로젝트. 자발적 컴퓨팅 프로젝트 중 가장 유명함.

<br>

자발적 컴퓨팅 프로젝트는 청크(chunk)라는 작업 단위로 해결할 문제들을 분리하고 이를 분석하기 위해 전 세계의 컴퓨터로 보낸다. 분석이 완료되면 서버로 전송되고 의도적인 방해를 막기 위해 각 작업 단위는 다른 세 대의 컴퓨터에 보내지고, 적어도 두 개의 결과 같아야 그 결과를 인정받는다.

<br>
맵리듀스(병렬 처리를 위해 문제를 독립된 조각으로 쪼갠다.)와 유사해 보이지만 사실은 큰 차이가 있다.

- 자발적 컴퓨팅 : CPU 중심적이고, 작업 단위를 전속하는 시간이 계산하는 시간보다 빠르기 때문에 전 세계 수십만 대의 컴퓨터에서 실행하는데 적합. 네트워크 대역폭이 아닌 CPU 사이클

- 맵리듀스 : 매우 높은 네트워크 대역폭을 가진 단일 데이터 센터에 있는 신뢰성 높은 전용 하드웨어에서 수 분 또는 수 시간 내에 잡을 실행할 수 있도록 설계.

<br>

[목차로](#home1)

<br><br>
<a id="6"></a>

# 하둡 역사

<br>

- 2002 : 너치 프로젝트/ 크롤러와 검색 시스템이 만들어 짐. 이 프로젝트 아키텍처는 수십억 웹 페이지로 확장할 수 없었음.
- 2003 : 구글에서 GFS라는 구글 분산 파일시스템 아키텍처를 설명한 논문 발표
- 2004 : NDFS(Nutch Distributed FileSystem) 를 오픈 소스로 구현하는 작업 실행
- 2004 : 구글의 맵리듀스 논문 발표
- 2005 : 너치 내부에 맵리듀스 구현
- 2006 : NDFS와 맵리듀스는 하둡이라는 이름의 독립된 루씬의 서브프로젝트로 너치에서 분리
- 2008 : 야후에서 10,000개의 코어를 가진 하둡 클러스터에서 검색 색인 생성 발표
- 2008 : 하둡 개발 성공과 다양성 및 활발한 커뮤니티의 공로를 인정받아 아파치 최상위 프로젝트로 등극
- 2008 : 하둡은 테라바이트 데이터 정렬 세계 신기록을 세운 가장 빠른 시스템 선정(910개의 노드로 1TB 데이터 209초만에 정렬)
- 2009 : 야후에서 하둡으로 1TB 62초 정렬 공표
- 2014 : 데이터브릭스팀 100TB 데이터 분당 4.27 테라바이트의 속도로 1,406초만에 정렬 성공

<br>

[목차로](#home1)
