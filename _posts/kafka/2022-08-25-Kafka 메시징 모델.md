---
title: "Kafka 메시징 모델"
# header:
#   image: /assets/images/hadoop/hadoop_logo.svg
#   caption: "Photo credit: [**Unsplash**](https://unsplash.com)"
layout: posts
categories:
  - Kafka
tags:
  - Kafka
  - Ingetion
toc: true
toc_sticky: true

date: 2022-08-25
last_modified_at: 2022-08-25
---

<br><br>

카프카는 다음과 같은 요구 사항을 만족시켜야 했다.

- 높은 처리량으로 실시간 처리
- 임의의 타이밍에 데이터를 읽는다.
- 다양한 제품과 시스템에 쉽게 연동한다.

<br>

그러므로 카프카는 메시징 모델을 채용 했으며 아래 3가지 요소로 구성된다.

- Producer : 메시지 생산자
- Brocker : 메시지 수집/전달 역할
- Consumer : 메시지 소비자

<br>

<div align='center'>
<img src='https://user-images.githubusercontent.com/45858414/186652865-a9f249f4-b827-4a47-a20c-b9d67be17529.png' width='70%' />
</div>

<br>

카프카는 기존의 메시징 모델인 `큐잉(queuing) 모델` 과 `Publish/Subscribe (펍/섭) 메시징 모델` 두 가지의 특징을 함께 가진 형태로 만들어졌다.

<br><br>

# 1. 큐잉 모델

<br>

Broker 안에 큐를 준비해, Producer에서의 메시지가 큐에 담기고, Consumer가 큐에서 메시지를 추출한다. 하나의 큐에 대해 컨슈머가 여러 개 존재하는 것을 생각할 수 있다. 이 모델은 컨슈머를 여러 개 준비함으로써 컨슈머에 의한 처리를 확장시킬 수 있으며, 컨슈머가 메시지를 받으면 다른 컨슈머는 메시지를 받을 수 없다.

<br>

<div align='center'>
<img src='https://user-images.githubusercontent.com/45858414/186654264-69a56df3-0cf4-4959-9522-d1f061e10973.png' width='70%' />
</div>

<br>

- 큐에서 여러 개의 컨슈머가 메시지를 추출할 수 있어 컨슈머에 의한 처리가 병렬로 가능하다.
- 큐에서 추출된 메시지는 컨슈머에 도달하면 사라진다. 즉 하나의 메시지는 여러 컨슈머 중 어느 하나에서 처리한다.

<br><br>

# 2. 펍/섭 메시징 모델

<br>

메시지 생산자인 프로듀서를 `Publisher`, 메시지 소비자의 해당 컨슈머를 `Subscriber`라고 한다.

Publisher 가 Subscrber에게 직접 메시지를 보내는 것이 아니라 Broker 를 통해 전달한다. Publisher는 누가 그 메시지를 수신하는지 알 수 없고 브로커에 있는 Topic 이라고 불리는 카테고리 안에 메시지를 등록한다.

<br>
<div align='center'>
<img src='https://user-images.githubusercontent.com/45858414/186656049-ac16b490-c46e-4e82-a0ed-1957f9b52d81.png' width='70%' />
</div>
<br>

- Publisher 는 Broker에 메시지를 보내기만 할 뿐 누가 그 메시지를 이용하는지는 신경 쓰지 않는다.
- Publisher 가 보낸 메시지는 Broker 내의 토픽이라 불리는 부분에 등록된다.

<br>

Subscriber는 여러 개 존재하는 토픽 중 하나를 선택하여 메시지를 받는다. 여러 Subscriber가 동일한 Topic을 구독하기로 결정한다면, 이 여러 Subscriber는 동일한 메시지를 받는다. 또한 다른 Topic 에서는 다른 메시지를 받을 수 있다.

<br>

<div align='center'>
<img src='https://user-images.githubusercontent.com/45858414/186656387-6d8c4ca9-ffc9-4a3e-a04d-9534b98dd2c5.png' width='70%' />
</div>

<br>

- Subscriber 는 Broker 내의 Topic 에서 자신이 흥미 있는 것만을 선택한다.
- 큐잉 모델과는 달리 같은 토픽을 구독하는 여러 Subscriber에게는 동일한 메시지가 전달된다.

<br><br>

# 3. Producer / Consumer 사이에 Broker를 끼우는 장점

<br>

큐잉 모델이든, 펍/섭 메시징 모델이든 모두 브로커를 사이에 끼우는 형태의 모델이다. 이 모델을 이용하면 변경에 강한 시스템 아키텍처를 만들 수 있다는 장점이 있다.

- 프로듀서/컨슈머 모두 접속처를 하나로 할 수 있다. (= 수를 줄일 수 있다.)

프로듀서는 누구에게 메시지를 전송하면 좋을지 생각할 필요 없이 브로커로 보내기만 하면 된다.
마찬가지로 컨슈머도 단순히 브로커에서만 수신하면 된다. 브로커가 존재하지 않는 경우 프로듀서가 컨슈머에게 메시지를 보내려면 다수의 프로듀서와 컨슈머를 모두 연결해야 할 수도 있다. 그러기 위해서는 시스템 토폴로지를 모두 이해해야 하거니와 구성을 변경할 때는 별도의 제작이 필요하다. 브로커의 존재는 `N x M`의 시스템 구성을 `N + M` 으로 만들어 구성을 단순하게 한다.

- 프로듀서/컨슈머 증감에 대응할 수 있다(네트워크 토폴로지 변경에 강하다).

프로듀서/컨슈머 모두 서로의 존재를 몰라도 되기 때문에 증감에 유연하게 대응할 수 있다. 프로듀서를 증가시키려면 브로커에만 접속하면 되며, 컨슈머도 브로커에 접속만하면 새로운 수신을 시작할 수 있다. 프로듀서/컨슈머 접속 관계에 변경이 생겨도 기존 프로듀서/컨슈머는 영향받지 않는다. 접속 시작을 위한 구현 부하가 낮다는 점, 기존 환경에 영향을 주지 않는다는 점에서 `변경에 강하다`고 할 수 있다.

<div align='center'>
<img src = 'https://user-images.githubusercontent.com/45858414/186658379-a0bfd107-61a3-4845-a38f-f47ef8bccaf3.png' width='70%' />
</div>

<br>

- Broker를 경유함에 따라 Producer와 Consumer를 개별로 접속하는 것을 회피할 수 있다.
- Producer, Consumer 모두 증가하거나 감소한다고 해도 다른 구성에 영향을 주지 않기 때문에 변경에 강하다.

<br>

펍/섭 메시징 모델은 TV나 라디오 전파 수신을 상상하면 이해하기 쉽다. TV 방송국과 라디오 방송국은 개별 가정에서 누가 수신하고 있는지 고려하지 않고 방송 전파를 발신하며, 각 가정은 자신이 보고 싶은 프로그램만 선택하여 방송을 ㅅ구신한다. 이렇게 하면 발신자와 수신자 연결이 유연한 장점이 있다. 이와 같은 구조를 시스템 간 실현한다고 생각하면 된다. 시스템 아키텍처에 있어서 이 발신자와 수신자의 교환을 중개하는 브로커가 존재함으로써 펍/섭 메시징 모델이 형성된다.

1개의 토픽에 주목한 경우를 큐잉 모델과 비교하면 여럿이 존재하는 모든 서브스크라이버는 동일한 메시지를 받게 된다. 병렬로 동작하는 복수의 서브스크라이버에 전달할 수 있다는 장점이 있지만, 동일한 메시지에 대한 처리이기 때문에 브로커의 토픽에 축적되는 메시지 그룹 입장에서 보면 처리 능력을 높이는 효과는 없다. 따라서 큐잉 모델과 펍/섭 메시징 모델은 장점과 단점이 공존한다.

<br><Br>

# 4. Kafka 메시징 모델

<br>

높은 처리량을 실현하기 위해서는 어떻게 확장성 있는 구성을 할 수 있을지가 관건이다.

따라서 카프카에서는 큐잉 모델에서 실현한 `여러 컨슈머가 분산 처리로 메시지를 소비`하는 모델과 펍/섭 메시징 모델에서 실현한 `여러 서브스크라이버에 동일한 메시지를 전달`하고, `토픽 기반으로 전달 내용을 변경`하는 모델로 되어 있다. 이 모델을 실현하기 위해 `컨슈머 그룹`이라는 개념을 도입하여 컨ㅅ슈머를 확장 구성할 수 있도록 설계하고 있다.

<br>
<div align='center'>
<img src='https://user-images.githubusercontent.com/45858414/186660673-50571d5a-c131-4bc4-bcbb-9aee7874fb52.png' width='70%' />
</div>

- pub/sub 메시징 모델을 기반으로 여러 컨슈머가 분산 처리하기 위해 컨슈머 그룹이라는 개념을 도입했다.

여러 컨슈머가 동일 토픽을 분산하여 메시지를 읽음으로써 처리의 확장성을 담보한다. 단, 시스템 구성상 브로커가 1대라면 그곳이 병목이 될 거라고 쉽게 상상할 수 있다. 또한 장기간에 걸쳐 임의의 타이밍에 데이터를 읽도록 하려면 1대만으로는 유지할 수 있는 양이 부족할지도 모른다. 따라서 브로커도 복수 구성으로 동작하도록 되었으며, 결과적으로는 전체적으로 확장 구성을 하고 있는 셈이다.
